# -*- coding: utf-8 -*-
"""Optimization_project_final_Bertolotti_Cappiello_Pagan.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/135ev3vB9a82iiUhc9vT7LXHAxFqzKHuk
"""

#Install necessary packages if not already available in the Colab environment
!apt-get install -y -qq glpk-utils
!which glpsol

"""**Import** **required** **libraries**"""

import pyomo.environ as pyo
from pyomo.environ import *
from pyomo.opt import SolverFactory
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
from google.colab import files

"""**Create the optimization model**"""

def create_optw_model(cities, interest, cost, time_matrix, budget, cost_pass, insur_cost, total_days, max_travel_days, lambda_, alpha, max_days_per_city):
    num_cities = len(cities)
    model = ConcreteModel()
    model.Cities = RangeSet(1, num_cities)

    # Decision variables
    model.y = Var(model.Cities, model.Cities, within=Binary)         # travel arc from city i to city j
    model.x = Var(model.Cities, within=NonNegativeIntegers)          # number of days in city i
    model.z = Var(model.Cities, within=Binary)                       # 1 if city i is visited
    model.g = Var(within=NonNegativeIntegers)                        # total travel days
    model.u = Var(model.Cities, within=NonNegativeReals, bounds=(0, num_cities - 1))  # MTZ subtour elimination

    # Objective: maximize utility of stay, reward for visiting more cities, penalty for travel time
    model.obj = Objective(
        expr=sum(interest[i-1] * model.x[i] for i in model.Cities)
           + alpha * sum(model.z[i] for i in model.Cities)
           - lambda_ * sum(time_matrix[i-1][j-1] * model.y[i, j]
                           for i in model.Cities for j in model.Cities if i != j),
        sense=maximize
    )

    # Constraints
    model.total_days = Constraint(expr=sum(model.x[i] for i in model.Cities) + model.g <= total_days)
    model.travel_days = Constraint(expr=model.g <= max_travel_days)
    model.budget_limit = Constraint(expr=sum(cost[i-1] * model.x[i] for i in model.Cities) + cost_pass + insur_cost <= budget)

    # Visiting constraints
    model.visiting = ConstraintList()
    for i in model.Cities:
        model.visiting.add(model.x[i] <= 30 * model.z[i])
        model.visiting.add(model.x[i] >= model.z[i])
        model.visiting.add(model.x[i] <= model.z[i] * max_days_per_city)

    # Flow conservation constraints
    model.flow = ConstraintList()
    for i in model.Cities:
        model.flow.add(sum(model.y[i, j] for j in model.Cities if j != i) == model.z[i])
        model.flow.add(sum(model.y[j, i] for j in model.Cities if j != i) == model.z[i])
        model.flow.add(model.y[i, i] == 0)

    # Start and end in Milan (city 1)
    model.departure = Constraint(expr=sum(model.y[1, j] for j in model.Cities if j != 1) == 1)
    model.return_trip = Constraint(expr=sum(model.y[j, 1] for j in model.Cities if j != 1) == 1)

    # Number of arcs equals number of travel days
    model.routes = Constraint(expr=sum(model.y[i, j] for i in model.Cities for j in model.Cities) == model.g)

    # Subtour elimination using Miller-Tucker-Zemlin (MTZ) constraints
    model.subtour_constraints = ConstraintList()
    model.subtour_constraints.add(model.u[1] == 0)
    for i in model.Cities:
        for j in model.Cities:
            if i != j and i != 1 and j != 1:
                model.subtour_constraints.add(
                    model.u[i] + 1 <= model.u[j] + (num_cities - 1) * (1 - model.y[i, j])
                )

    # Link between routes and visits
    model.y_z_link = ConstraintList()
    for i in model.Cities:
        for j in model.Cities:
            if i != j:
                model.y_z_link.add(model.y[i, j] <= model.z[i])
                model.y_z_link.add(model.y[i, j] <= model.z[j])

    return model

"""**Upload the Excel file**"""

uploaded = files.upload()

df = pd.read_excel('interrail_data.xlsx')
print(df.head())

def get_data_from_excel(file_name):
    data1 = pd.read_excel(file_name, sheet_name="data")
    cities = data1["city"].tolist()
    interest = data1["interest"].tolist()
    cost = data1["cost"].tolist()

    data2 = pd.read_excel(file_name, sheet_name="time_matrix", index_col=0)
    time_matrix = data2.loc[cities, cities].values

    return cities, interest, cost, time_matrix

"""**Parameters**"""

cost_pass = 286
insur_cost = 55
budget = 2500
total_days = 30
max_travel_days = 7
lambda_ = 0.02
alpha = 3
file_name = "interrail_data.xlsx"  # Make sure this matches the uploaded filename
max_days_per_city = 5

"""**Load** **data**"""

cities, interest, cost, time_matrix = get_data_from_excel(file_name)
print("Cities:", cities)
print("Interest:", interest)
print("Cost per day:", cost)
print("Time matrix shape:", time_matrix.shape)

"""**Create and solve the model**"""

model = create_optw_model(cities, interest, cost, time_matrix, budget, cost_pass, insur_cost, total_days, max_travel_days, lambda_, alpha, max_days_per_city)
solver = SolverFactory("glpk", executable="/usr/bin/glpsol")
results = solver.solve(model, tee=True, timelimit=600)

# Extract and organize solution
solution = []
for i in model.Cities:
    for j in model.Cities:
        if i != j and pyo.value(model.y[i, j]) > 0.5:
            solution.append((cities[i-1], cities[j-1]))

# Reorder the travel path
def reorder_path(solution, node_list):
    start = node_list[0]
    end = node_list[0]
    current = start
    ordered_arcs = []
    ordered_nodes = []

    while current != end or not ordered_nodes:
        ordered_nodes.append(current)
        found = False
        for arc in solution:
            if arc[0] == current:
                ordered_arcs.append(arc)
                current = arc[1]
                found = True
                break
        if not found:
            break  # Avoid infinite loop

    ordered_nodes.append(end)
    return ordered_arcs, ordered_nodes

ordered_arcs, ordered_cities = reorder_path(solution, cities)

# Print results
print(f"Objective value: {pyo.value(model.obj):.2f}")
print("\n--- Sequence of visited cities and days of stay ---")
for city in ordered_cities[:-1]:  # Skip repeated last city
    idx = cities.index(city) + 1  # Pyomo indexing starts at 1
    days = round(pyo.value(model.x[idx]))
    print(f"{city} ({days} day{'s' if days > 1 else ''})")

print("\n--- Ordered travel arcs ---")
for arc in ordered_arcs:
    print(f"{arc[0]} → {arc[1]}")

print("\n--- Full travel sequence ---")
print(" → ".join(ordered_cities))

print(f"\nTotal travel days: {sum(model.x[i].value for i in model.Cities) + model.g.value:.1f}")

"""**Plot of the interrail route**"""

def plot_interrail_graph_with_milan_and_days(model, cities):
    graph = nx.DiGraph()
    edges = []

    starting_city = cities[0]
    days_stay = {}

    for i in model.Cities:
        days_stay[cities[i - 1]] = round(pyo.value(model.x[i]))

    for i in model.Cities:
        for j in model.Cities:
            if i != j and pyo.value(model.y[i, j]) == 1:
                city_i = cities[i - 1]
                city_j = cities[j - 1]
                graph.add_edge(city_i, city_j)
                edges.append((city_i, city_j))

    positions = nx.spring_layout(graph, seed=42)
    plt.figure(figsize=(12, 8))
    node_colors = ['lightgreen' if city == starting_city else 'lightblue' for city in graph.nodes()]

    # Create labels with city name and days stayed
    labels = {city: f"{city}\n{days_stay[city]} day{'s' if days_stay[city] != 1 else ''}" for city in graph.nodes()}

    nx.draw(graph, positions, with_labels=False, node_size=3000, node_color=node_colors,
            font_size=10, font_weight='bold', arrows=True, arrowsize=20)

    # Draw labels manually to customize multiline text
    nx.draw_networkx_labels(graph, positions, labels=labels, font_size=9, font_weight='bold')

    plt.title("Optimal Interrail Route with Days Stayed in Each City (start/end Milan)", fontsize=14)
    plt.axis('off')
    plt.show()

    return edges

# Final plot with days shown
edges = plot_interrail_graph_with_milan_and_days(model, cities)

"""# **Sensitivity analysis on budget**

**Plot**
"""

def plot_interrail_graph_with_milan_and_days(model, cities, current_budget):
    graph = nx.DiGraph()
    edges = []

    starting_city = cities[0]
    days_stay = {}

    for i in model.Cities:
        days_stay[cities[i - 1]] = round(pyo.value(model.x[i]))

    for i in model.Cities:
        for j in model.Cities:
            if i != j and pyo.value(model.y[i, j]) == 1:
                city_i = cities[i - 1]
                city_j = cities[j - 1]
                graph.add_edge(city_i, city_j)
                edges.append((city_i, city_j))

    positions = nx.spring_layout(graph, seed=42)
    plt.figure(figsize=(12, 8))
    node_colors = ['lightgreen' if city == starting_city else 'lightblue' for city in graph.nodes()]

    labels = {city: f"{city}\n{days_stay[city]} day{'s' if days_stay[city] != 1 else ''}" for city in graph.nodes()}

    nx.draw(graph, positions, with_labels=False, node_size=3000, node_color=node_colors,
            font_size=10, font_weight='bold', arrows=True, arrowsize=20)

    nx.draw_networkx_labels(graph, positions, labels=labels, font_size=9, font_weight='bold')

    plt.title(f"Optimal Interrail Route with Days Stayed (Budget = {budget})", fontsize=14)
    plt.axis('off')
    plt.show()

    return edges

# Define a list of budget values to test
budget_values = [2000, 2500, 3000]

# Dictionary to store results keyed by budget
results_by_budget = {}
objective_values = []

for current_budget in budget_values:
    print(f"\n--- Solving model with budget = {current_budget} ---")

    # Create a new model instance with the current budget
    model = create_optw_model(cities, interest, cost, time_matrix,
                             current_budget, cost_pass, insur_cost, total_days,
                             max_travel_days, lambda_, alpha, max_days_per_city)

    # Solve the model
    solver = SolverFactory("glpk", executable="/usr/bin/glpsol")
    results = solver.solve(model, tee=False, timelimit=60)

    # Extract solution
    solution = []
    for i in model.Cities:
        for j in model.Cities:
            if i != j and pyo.value(model.y[i, j]) > 0.5:
                solution.append((cities[i-1], cities[j-1]))

    ordered_arcs, ordered_cities = reorder_path(solution, cities)

    # Collect results
    city_days = {}
    for city in ordered_cities[:-1]:  # skip last repeated city
        idx = cities.index(city) + 1
        city_days[city] = round(pyo.value(model.x[idx]))

    obj_val = pyo.value(model.obj)
    objective_values.append(obj_val)

    results_by_budget[current_budget] = {
        'ordered_cities': ordered_cities,
        'ordered_arcs': ordered_arcs,
        'city_days': city_days,
        'objective_value': pyo.value(model.obj)
    }

    # Print summary
    print(f"Objective value: {results_by_budget[current_budget]['objective_value']:.2f}")
    print("Visited cities and days of stay:")
    for city, days in city_days.items():
        print(f"  {city}: {days} day{'s' if days > 1 else ''}")
    print("Travel sequence:")
    print(" → ".join(ordered_cities))
    print(f"\nTotal travel days: {sum(model.x[i].value for i in model.Cities) + model.g.value:.1f}")


    plot_interrail_graph_with_milan_and_days(model, cities, current_budget)

"""**Plot trend of objective function value vs budget**"""

plt.figure(figsize=(8, 5))
plt.plot(budget_values, objective_values, marker='o', linestyle='-')
plt.title('Objective Function Value vs Budget')
plt.xlabel('Budget')
plt.ylabel('Objective Function Value')
plt.grid(True)
plt.show()

"""# **Sensitivity analysis on alpha**

**Plot**
"""

def plot_interrail_graph_with_milan_and_days(model, cities, alpha):
    graph = nx.DiGraph()
    edges = []

    starting_city = cities[0]
    days_stay = {}

    for i in model.Cities:
        days_stay[cities[i - 1]] = round(pyo.value(model.x[i]))

    for i in model.Cities:
        for j in model.Cities:
            if i != j and pyo.value(model.y[i, j]) == 1:
                city_i = cities[i - 1]
                city_j = cities[j - 1]
                graph.add_edge(city_i, city_j)
                edges.append((city_i, city_j))

    positions = nx.spring_layout(graph, seed=42)
    plt.figure(figsize=(12, 8))
    node_colors = ['lightgreen' if city == starting_city else 'lightblue' for city in graph.nodes()]

    labels = {city: f"{city}\n{days_stay[city]} day{'s' if days_stay[city] != 1 else ''}" for city in graph.nodes()}

    nx.draw(graph, positions, with_labels=False, node_size=3000, node_color=node_colors,
            font_size=10, font_weight='bold', arrows=True, arrowsize=20)

    nx.draw_networkx_labels(graph, positions, labels=labels, font_size=9, font_weight='bold')

    plt.title(f"Optimal Interrail Route with Days Stayed (Alpha = {alpha})", fontsize=14)
    plt.axis('off')
    plt.show()

    return edges

# List of alpha values to test
alpha_values = [1, 3, 5]

# Dictionary to store results
results_by_alpha = {}
objective_values = []

# Fixed budget
budget = 2500

for current_alpha in alpha_values:
    print(f"\n--- Solving model with alpha = {current_alpha} ---")

    # Create model with current alpha
    model = create_optw_model(cities, interest, cost, time_matrix,
                             budget, cost_pass, insur_cost, total_days,
                             max_travel_days, lambda_, current_alpha, max_days_per_city)

    # Solve the model
    solver = SolverFactory("glpk", executable="/usr/bin/glpsol")
    results = solver.solve(model, tee=False, timelimit=60)

    # Extract solution
    solution = []
    for i in model.Cities:
        for j in model.Cities:
            if i != j and pyo.value(model.y[i, j]) > 0.5:
                solution.append((cities[i-1], cities[j-1]))

    ordered_arcs, ordered_cities = reorder_path(solution, cities)

    # Extract number of days stayed in each city
    city_days = {}
    for city in ordered_cities[:-1]:  # Skip last repeated city
        idx = cities.index(city) + 1
        city_days[city] = round(pyo.value(model.x[idx]))

    # Store results
    obj_val = pyo.value(model.obj)
    objective_values.append(obj_val)

    results_by_alpha[current_alpha] = {
        'ordered_cities': ordered_cities,
        'ordered_arcs': ordered_arcs,
        'city_days': city_days,
        'objective_value': obj_val
    }

    # Print summary
    print(f"Objective value: {obj_val:.2f}")
    print("Visited cities and days of stay:")
    for city, days in city_days.items():
        print(f"  {city}: {days} day{'s' if days > 1 else ''}")
    print("Travel sequence:")
    print(" → ".join(ordered_cities))
    print(f"\nTotal travel days: {sum(model.x[i].value for i in model.Cities) + model.g.value:.1f}")

    # Plot graph for current alpha
    plot_interrail_graph_with_milan_and_days(model, cities, current_alpha)

"""**Plot trend of objective function value vs alpha**"""

plt.figure(figsize=(8, 5))
plt.plot(alpha_values, objective_values, marker='o', linestyle='-', color='darkred')
plt.title('Objective Function Value vs Alpha')
plt.xlabel('Alpha (Bonus for Visiting Cities)')
plt.ylabel('Objective Function Value')
plt.grid(True)
plt.show()

"""# **Sensitivity analysis on lambda**

**Plot**
"""

def plot_interrail_graph(model, cities, param_value, param_name="Parameter"):
    graph = nx.DiGraph()
    edges = []

    starting_city = cities[0]
    days_stay = {}

    for i in model.Cities:
        days_stay[cities[i - 1]] = round(pyo.value(model.x[i]))

    for i in model.Cities:
        for j in model.Cities:
            if i != j and pyo.value(model.y[i, j]) == 1:
                city_i = cities[i - 1]
                city_j = cities[j - 1]
                graph.add_edge(city_i, city_j)
                edges.append((city_i, city_j))

    positions = nx.spring_layout(graph, seed=42)
    plt.figure(figsize=(12, 8))
    node_colors = ['lightgreen' if city == starting_city else 'lightblue' for city in graph.nodes()]

    labels = {city: f"{city}\n{days_stay[city]} day{'s' if days_stay[city] != 1 else ''}" for city in graph.nodes()}

    nx.draw(graph, positions, with_labels=False, node_size=3000, node_color=node_colors,
            font_size=10, font_weight='bold', arrows=True, arrowsize=20)

    nx.draw_networkx_labels(graph, positions, labels=labels, font_size=9, font_weight='bold')

    plt.title(f"Optimal Interrail Route with Days Stayed ({param_name} = {param_value})", fontsize=14)
    plt.axis('off')
    plt.show()

    return edges

# Sensitivity analysis for lambda
lambda_values = [0.01, 0.02, 0.05]
objective_values = []
results_by_lambda = {}

# Fixed values
budget = 2500
alpha = 3

for current_lambda in lambda_values:
    print(f"\n--- Solving model with lambda = {current_lambda} ---")

    model = create_optw_model(cities, interest, cost, time_matrix,
                              budget, cost_pass, insur_cost, total_days,
                              max_travel_days, current_lambda, alpha, max_days_per_city)

    solver = SolverFactory("glpk", executable="/usr/bin/glpsol")
    results = solver.solve(model, tee=False, timelimit=60)

    solution = []
    for i in model.Cities:
        for j in model.Cities:
            if i != j and pyo.value(model.y[i, j]) > 0.5:
                solution.append((cities[i-1], cities[j-1]))

    ordered_arcs, ordered_cities = reorder_path(solution, cities)

    city_days = {}
    for city in ordered_cities[:-1]:  # skip last repeated city
        idx = cities.index(city) + 1
        city_days[city] = round(pyo.value(model.x[idx]))

    obj_val = pyo.value(model.obj)
    objective_values.append(obj_val)

    results_by_lambda[current_lambda] = {
        'ordered_cities': ordered_cities,
        'ordered_arcs': ordered_arcs,
        'city_days': city_days,
        'objective_value': obj_val
    }

    print(f"Objective value: {obj_val:.2f}")
    print("Visited cities and days of stay:")
    for city, days in city_days.items():
        print(f"  {city}: {days} day{'s' if days > 1 else ''}")
    print("Travel sequence:")
    print(" → ".join(ordered_cities))
    print(f"\nTotal travel days: {sum(model.x[i].value for i in model.Cities) + model.g.value:.1f}")

    # Graph for current lambda
    plot_interrail_graph(model, cities, current_lambda, param_name="λ")

"""**Plot trend of objective function value vs lambda**"""

plt.figure(figsize=(8, 5))
plt.plot(lambda_values, objective_values, marker='o', linestyle='-')
plt.title("Objective Function Value vs λ (lambda)")
plt.xlabel("λ (lambda)")
plt.ylabel("Objective Function Value")
plt.grid(True)
plt.show()